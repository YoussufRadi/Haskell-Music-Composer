# Haskell-Music-Composer
A Music Composer that learns from a famous pattern and generates a music string dynamically based on that pattern

To Contact me Click [Here](http://youssufradi.github.io/)
<h3>Project Description</h3>
<p>
Implementing a simple algorithmic music composer. It should be able to learn some
statistics from a number of given strings representing famous musical pieces and then use these statistics
to generate new strings representing new pieces.</br>
We are using this website http://virtualpiano.net/. It provides a virtual piano on which you can
play using the keyboard. Moreover, it provides music sheets of a collection of famous songs.
For this project, we have chosen a number of strings from those provided on the virtual piano website and
modified them a bit so that they would include only the characters [0-9], [a-z] and [’B’,’C’,’D’,’E’,
’G’,’H’,’I’,’J’,’L’,’O’,’P’,’Q’,’S’,’T’,’V’,’W’,’Y’,’Z’]. The file MusicResources.hs will con-
tain these strings. Code should use the list training from that file in order to learn. Make sure that file in the same folder as your solution .hs file.
</p>
<h4>
makeHelper4 :: Char -> [Char] -> [Char]
</h4>
makeHelper4 c (x:xs)
Takes a Char c and a List of Chars (x:xs) (String) and returns a list of Chars (String)
for any Char that comes just after the Char c
<h4>
makeHelper5 :: Char -> [[Char]] -> [Char]
</h4>
makeHelper5 c (x:xs)
Takes a Char c and a List (x) of list of Chars (x:xs) (Calls makeHelper4) returns a
list of Chars (String) for any Char that comes just after the Char c in all the list (x:xs)
<h4>
makeHelper6 :: Char -> [Char]
</h4>
makeHelper6 c
Just calls makeHelper5 for the Char c and list training from music resources
<h4>
pack ::Char -> [Char] -> [(Int,Char)]
</h4>
pack c xs
Takes a Char c and return a pack contains the number of repetition of the Char c in the
list xs in a pack (Number of repetition, Char c)
<h4>
possiblePack1 :: [Char] -> [Char] -> [(Int,Char)]
</h4>
possiblePack1 (x:xs) cs
Find all the possible packs for list chars in training in the list cs given form makeHelper6
<h4>
possiblePack :: Char -> (Char,[(Int,Char)])
</h4>
possiblePack c
calls the function possiblePack for all chars and sorts it in a descending order
<h4>
makeStatsList :: [(Char,[(Int,Char)])]
</h4>
makeStatsList
Maps the function possiblePack for all chars--
<h4>
sumf :: [(Int,Char)] -> Int
</h4>
sumf (x:xs)
Gets the sum of the first element in the in the pair(x) and does it for list (x:xs)
<h4>
findELm :: Int -> [(Int,Char)] -> (Int,Char)
</h4>
findELm c (x:xs)
takes a random number as c and finds the position that the cumulative sum of elements
in the list sums up to this number
<h4>
getElm1 :: [(Int,Char)] -> (Int,Char)
</h4>
getElm1 x
Takes a list x calls findElm element with c equals to a random number from 1 to sum of
the list x
<h4>
getElm :: [(Int,Char)] -> Char
</h4>
getElm x
get the second element of the pair
<h4>
findx :: Char -> Char
</h4>
findx c
calls findx1 of c and a list generated by makeStatsList
<h4>
findx1 :: Char -> [(Char,[(Int,Char )])] -> Char
</h4>
findx1 c (x:xs)
Takes a Char c and searches in the list (x:xs) for the element that contains c as it first
parameter then calls getElm.
Handels the Case if a number is chosen that have no numbers after it, therefore it
throws an error “Dead End”
<h4>
compose :: Char -> Int -> [Char]
</h4>
compose x k
Append x with the result from compose1compose1 :: Char -> Int -> [Char]
compose1 x k
calls findx for Char x to find a random char and appends it with other random Chars until
the length of list (String) is K
<h4>
remove :: [(Char,[(Int,Char)])]
</h4>
remove
Calls remove1 for list makeStatsList
<h4>
remove1 :: [(Char,[(Int,Char)])] -> [(Char,[(Int,Char)])]
</h4>
remove1 (x:xs)
Checks if the second element of pair is empty [] it removes it form the list
<h4>
contains :: Char -> Bool
</h4>
contains code
calls contains1 for Char c and list from remove
<h4>
contains1 :: Eq a => a -> [(a,b)] -> Bool
</h4>
contains1 c (x:xs)
</h4>
checks if the Char c is an element of the first pair in the list of list of pairs (x:xs)
